(function(global,factory){if(typeof define==="function"&&define.amd){define("amazonLocationDataConverter",["exports"],factory)}else if(typeof exports!=="undefined"){factory(exports)}else{var mod={exports:{}};factory(mod.exports);global.amazonLocationDataConverter=mod.exports}})(typeof globalThis!=="undefined"?globalThis:typeof self!=="undefined"?self:this,function(_exports){"use strict";Object.defineProperty(_exports,"__esModule",{value:true});_exports.devicePositionsToFeatureCollection=devicePositionsToFeatureCollection;_exports.featureCollectionToGeofence=featureCollectionToGeofence;_exports.geofencesToFeatureCollection=geofencesToFeatureCollection;_exports.placeToFeatureCollection=placeToFeatureCollection;_exports.routeToFeatureCollection=routeToFeatureCollection;function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen)}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_x,_r,_arr=[],_n=!0,_d=!1;try{if(_x=(_i=_i.call(arr)).next,0===i){if(Object(_i)!==_i)return;_n=!1}else for(;!(_n=(_s=_x.call(_i)).done)&&(_arr.push(_s.value),_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&null!=_i.return&&(_r=_i.return(),Object(_r)!==_r))return}finally{if(_d)throw _e}}return _arr}}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Third party license at https://github.com/aws-geospatial/amazon-location-utilities-datatypes-js/blob/main/LICENSE-THIRD-PARTY.txt
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a FeatureCollection with Polygon Features to an array of BatchPutGeofenceRequestEntry, so the result can
 * be used to assemble the request to BatchPutGeofence.
 *
 * It will map the id of the Feature to the `GeofenceId` field of the corresponding entry in the output.
 *
 * If it sees the `Circle` property in a Feature, it will be converted to a Circle Geofence using its `Center` and
 * `Radius` properties instead of a Polygon Geofence.
 *
 * <b>Note</b>: when converting the output of `geofencesToFeatureCollection` function, the following fields will be
 * removed as we can not set them when uploading geofences:
 *
 * 1. Status
 * 2. CreateTime
 * 3. UpdateTime
 *
 * @example Converting a polygon geofence
 *
 * Input:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * [{
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Polygon": [[
 *       [1, 2],
 *       [1, 3],
 *       [2, 3],
 *       [1, 2]
 *     ]]
 *   }
 * }]
 * ```
 *
 * @example Converting a circle geofence
 *
 * Input:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * [{
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Circle": {
 *       "Center": [1, 2],
 *       "Radius": 10.0
 *     }
 *   }
 * }]
 * ```
 */function featureCollectionToGeofence(featureCollection){return featureCollection.features.map(function(feature){return convertFeatureToGeofence(feature)}).filter(function(entry){return entry})}function convertFeatureToGeofence(feature){var _a,_b;if(feature&&((_a=feature.geometry)===null||_a===void 0?void 0:_a.type)=="Polygon"){if(feature.properties&&"center"in feature.properties){// Circular geofence
return{GeofenceId:String(feature.id),Geometry:{Circle:{Center:feature.properties.center,Radius:feature.properties.radius}}}}else if((_b=feature.geometry)===null||_b===void 0?void 0:_b.coordinates){return{GeofenceId:String(feature.id),Geometry:{Polygon:feature.geometry.coordinates}}}}}/**
 * @module helpers
 */ /**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */var earthRadius=6371008.8;/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */var factors={centimeters:earthRadius*100,centimetres:earthRadius*100,degrees:earthRadius/111325,feet:earthRadius*3.28084,inches:earthRadius*39.37,kilometers:earthRadius/1000,kilometres:earthRadius/1000,meters:earthRadius,metres:earthRadius,miles:earthRadius/1609.344,millimeters:earthRadius*1000,millimetres:earthRadius*1000,nauticalmiles:earthRadius/1852,radians:1,yards:earthRadius*1.0936};/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */function feature(geom,properties,options){if(options===void 0){options={}}var feat={type:"Feature"};if(options.id===0||options.id){feat.id=options.id}if(options.bbox){feat.bbox=options.bbox}feat.properties=properties||{};feat.geometry=geom;return feat}/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */function point(coordinates,properties,options){if(options===void 0){options={}}if(!coordinates){throw new Error("coordinates is required")}if(!Array.isArray(coordinates)){throw new Error("coordinates must be an Array")}if(coordinates.length<2){throw new Error("coordinates must be at least 2 numbers long")}if(!isNumber(coordinates[0])||!isNumber(coordinates[1])){throw new Error("coordinates must contain numbers")}var geom={type:"Point",coordinates:coordinates};return feature(geom,properties,options)}/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */function polygon(coordinates,properties,options){if(options===void 0){options={}}for(var _i=0,coordinates_1=coordinates;_i<coordinates_1.length;_i++){var ring=coordinates_1[_i];if(ring.length<4){throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.")}for(var j=0;j<ring[ring.length-1].length;j++){// Check if first point of Polygon contains two numbers
if(ring[ring.length-1][j]!==ring[0][j]){throw new Error("First and last Position are not equivalent.")}}}var geom={type:"Polygon",coordinates:coordinates};return feature(geom,properties,options)}/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */function lengthToRadians(distance,units){if(units===void 0){units="kilometers"}var factor=factors[units];if(!factor){throw new Error(units+" units is invalid")}return distance/factor}/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */function radiansToDegrees(radians){var degrees=radians%(2*Math.PI);return degrees*180/Math.PI}/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */function degreesToRadians(degrees){var radians=degrees%360;return radians*Math.PI/180}/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */function isNumber(num){return!isNaN(num)&&num!==null&&!Array.isArray(num)}/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */function getCoord(coord){if(!coord){throw new Error("coord is required")}if(!Array.isArray(coord)){if(coord.type==="Feature"&&coord.geometry!==null&&coord.geometry.type==="Point"){return coord.geometry.coordinates}if(coord.type==="Point"){return coord.coordinates}}if(Array.isArray(coord)&&coord.length>=2&&!Array.isArray(coord[0])&&!Array.isArray(coord[1])){return coord}throw new Error("coord must be GeoJSON Point or an Array of numbers")}// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */function destination(origin,distance,bearing,options){if(options===void 0){options={}}// Handle input
var coordinates1=getCoord(origin);var longitude1=degreesToRadians(coordinates1[0]);var latitude1=degreesToRadians(coordinates1[1]);var bearingRad=degreesToRadians(bearing);var radians=lengthToRadians(distance,options.units);// Main
var latitude2=Math.asin(Math.sin(latitude1)*Math.cos(radians)+Math.cos(latitude1)*Math.sin(radians)*Math.cos(bearingRad));var longitude2=longitude1+Math.atan2(Math.sin(bearingRad)*Math.sin(radians)*Math.cos(latitude1),Math.cos(radians)-Math.sin(latitude1)*Math.sin(latitude2));var lng=radiansToDegrees(longitude2);var lat=radiansToDegrees(latitude2);return point([lng,lat],options.properties)}/**
 * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.
 *
 * @name circle
 * @param {Feature<Point>|number[]} center center point
 * @param {number} radius radius of the circle
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.steps=64] number of steps
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] properties
 * @returns {Feature<Polygon>} circle polygon
 * @example
 * var center = [-75.343, 39.984];
 * var radius = 5;
 * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};
 * var circle = turf.circle(center, radius, options);
 *
 * //addToMap
 * var addToMap = [turf.point(center), circle]
 */function circle(center,radius,options){if(options===void 0){options={}}// default params
var steps=options.steps||64;var properties=options.properties?options.properties:!Array.isArray(center)&&center.type==="Feature"&&center.properties?center.properties:{};// main
var coordinates=[];for(var i=0;i<steps;i++){coordinates.push(destination(center,radius,i*-360/steps,options).geometry.coordinates)}coordinates.push(coordinates[0]);return polygon([coordinates],properties)}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * Converts an array of GeoJSON Features to a FeatureCollection.
 *
 * @param features An array of GeoJSON Features.
 * @returns A GeoJSON FeatureCollection containing provided Features.
 */function toFeatureCollection(features){return{type:"FeatureCollection",features:features.filter(function(feature){return feature})}}/**
 * Optionally flatten the Amazon Location Service object.
 *
 * @param obj Amazon Location Service object.
 * @returns Flattened object.
 */function flattenProperties(obj){var prefix=arguments.length>1&&arguments[1]!==undefined?arguments[1]:"";if(_typeof(obj)!=="object"||obj===null||Array.isArray(obj)){return{}}var result={};Object.entries(obj).forEach(function(_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];var newKey=prefix?"".concat(prefix,".").concat(key):key;if(_typeof(value)==="object"&&value!==null&&!Array.isArray(value)&&key!=="Geometry"){Object.assign(result,flattenProperties(value,newKey))}else{result[newKey]=value}});return result}function emptyFeatureCollection(){return{type:"FeatureCollection",features:[]}}function convertGeometryToFeature(geometry,properties){if(geometry){var _ref3=Object.entries(geometry).find(function(// eslint-disable-next-line @typescript-eslint/no-unused-vars
_ref5){var _ref6=_slicedToArray(_ref5,2),_=_ref6[0],coordinates=_ref6[1];return coordinates!=undefined})||[],_ref4=_slicedToArray(_ref3,2),type=_ref4[0],coordinates=_ref4[1];switch(type){case"Point":case"LineString":case"Polygon":return{type:"Feature",properties:Object.assign({},properties),geometry:{type:type,coordinates:coordinates}};case"Circle":{var center=coordinates.Center,radius=coordinates.Radius;return circle(center,radius,{units:"meters",properties:Object.assign({center:center,radius:radius},properties)})}}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts place responses to a FeatureCollection with Point Features. It converts
 *
 * 1. GetPlaceResponse to a FeatureCollection with a single feature.
 * 2. SearchPlaceIndexForPositionResponse, SearchPlaceIndexForTextResponse to a FeatureCollection with features
 *    corresponding to the entries in the response.
 *
 * `PlaceId` will be mapped to the `id` of the output Feature if `PlaceId` is provided. Fields other than `PlaceId` and
 * `Geometry` in a place will be mapped into the properties of the corresponding Feature.
 *
 * Any place without the `Point` field will be skipped.
 *
 * @example Drawing the result of SearchPlaceIndexForText with MapLibre could be simplified with this converter from the
 * below code:
 *
 * ```js
 * // ...
 * location.searchPlaceIndexForText(params, (err, result) => {
 *   if (err) {
 *     // error handling
 *   } else {
 *     const featureCollection = {
 *       type: "FeatureCollection",
 *       features:
 *         result?.Results?.map((result) => {
 *           return {
 *             type: "Feature",
 *             geometry: {
 *               type: "Point",
 *               properties: {}, // translate the properties here
 *               coordinates: result?.Place?.Geometry?.Point,
 *             },
 *           };
 *         }) || [],
 *     };
 *     map.addSource("search-result", featureCollection);
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * });
 * // ...
 * ```
 *
 * To:
 *
 * ```js
 * // ...
 * location.searchPlaceIndexForText(params, (err, result) => {
 *   if (err) {
 *     // error handling
 *   } else {
 *     const featureCollection = placeToFeatureCollection(result);
 *     map.addSource("search-result", featureCollection);
 *     map.addLayer({
 *       id: "search-result",
 *       type: "circle",
 *       source: "search-result",
 *       paint: {
 *         "circle-radius": 6,
 *         "circle-color": "#B42222",
 *       },
 *     });
 *   }
 * });
 * // ...
 * ```
 *
 * @example Converting a GetPlace result
 *
 * Result of GetPlace:
 *
 * ```json
 * {
 *   "Place": {
 *     "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *     "Geometry": {
 *       "Point": [-123.13, 49.28]
 *     },
 *     "AddressNumber": "1675",
 *     "Street": "Robson St",
 *     "Municipality": "Vancouver",
 *     "SubRegion": "Greater Vancouver",
 *     "Region": "British Columbia",
 *     "Country": "CAN",
 *     "PostalCode": "V6G 1C8",
 *     "Interpolated": false
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Place": {
 *           "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *           "AddressNumber": "1675",
 *           "Street": "Robson St",
 *           "Municipality": "Vancouver",
 *           "SubRegion": "Greater Vancouver",
 *           "Region": "British Columbia",
 *           "Country": "CAN",
 *           "PostalCode": "V6G 1C8",
 *           "Interpolated": false
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.13, 49.28]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Place.Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC, V6G 1C8, CAN",
 *         "Place.AddressNumber": "1675",
 *         "Place.Street": "Robson St",
 *         "Place.Municipality": "Vancouver",
 *         "Place.SubRegion": "Greater Vancouver",
 *         "Place.Region": "British Columbia",
 *         "Place.Country": "CAN",
 *         "Place.PostalCode": "V6G 1C8",
 *         "Place.Interpolated": false
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.13, 49.28]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a SearchPlaceIndexForTextResponse result with the second result missing the `Point` field
 *
 * Result of SearchPlaceIndexForTextResponse:
 *
 * ```json
 * {
 *   "Summary": {
 *     "Text": "whole foods",
 *     "BiasPosition": [-123.115, 49.295],
 *     "MaxResults": 2,
 *     "DataSource": "Here"
 *   },
 *   "Results": [
 *     {
 *       "Place": {
 *         "Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC V6G 1C8, Canada",
 *         "Geometry": {
 *           "Point": [-123.132, 49.29]
 *         },
 *         "AddressNumber": "1675",
 *         "Street": "Robson St",
 *         "Neighborhood": "West End",
 *         "Municipality": "Vancouver",
 *         "SubRegion": "Metro Vancouver",
 *         "Region": "British Columbia",
 *         "Country": "CAN",
 *         "PostalCode": "V6G 1C8",
 *         "Interpolated": false,
 *         "TimeZone": {
 *           "Name": "America/Vancouver",
 *           "Offset": -25200
 *         }
 *       },
 *       "Distance": 1385.945532454018,
 *       "PlaceId": "AQAAAHAArZ9I7WtFD"
 *     },
 *     {
 *       "Place": {
 *         "Label": "Whole Foods Market, 510 W 8th Ave, Vancouver, BC V5Z 1C5, Canada",
 *         "Geometry": {}
 *       },
 *       "PlaceId": "AQAAAHAA0gZK0c"
 *     },
 *     {
 *       "Place": {
 *         "Label": "Whole Foods, 925 Main St, West Vancouver, BC V7T, Canada",
 *         "Geometry": {
 *           "Point": [-123.142, 49.325]
 *         },
 *         "AddressNumber": "925",
 *         "Street": "Main St",
 *         "Neighborhood": "Capilano Indian Reserve 5",
 *         "Municipality": "West Vancouver",
 *         "SubRegion": "Metro Vancouver",
 *         "Region": "British Columbia",
 *         "Country": "CAN",
 *         "PostalCode": "V7T",
 *         "Interpolated": false,
 *         "TimeZone": {
 *           "Name": "America/Vancouver",
 *           "Offset": -25200
 *         }
 *       },
 *       "Distance": 3876.5708436735226,
 *       "PlaceId": "AQAAAHAAo5aDp0fMX"
 *     }
 *   ]
 * }
 * ```
 *
 * Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "AQAAAHAArZ9I7WtFD",
 *       "properties": {
 *          "Distance": 1385.945532454018
 *          "Place.Label": "Whole Foods Market, 1675 Robson St, Vancouver, BC V6G 1C8, Canada",
 *          "Place.AddressNumber": "1675",
 *          "Place.Street": "Robson St",
 *          "Place.Neighborhood": "West End",
 *          "Place.Municipality": "Vancouver",
 *          "Place.SubRegion": "Metro Vancouver",
 *          "Place.Region": "British Columbia",
 *          "Place.Country": "CAN",
 *          "Place.PostalCode": "V6G 1C8",
 *          "Place.Interpolated": false,
 *          "Place.TimeZone.Name": "America/Vancouver",
 *          "Place.TimeZone.Offset": -25200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.132, 49.29]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "id": "AQAAAHAAo5aDp0fMX",
 *       "properties": {
 *          "Distance": 3876.5708436735226
 *          "Place.Label": "Whole Foods, 925 Main St, West Vancouver, BC V7T, Canada",
 *          "Place.AddressNumber": "925",
 *          "Place.Street": "Main St",
 *          "Place.Neighborhood": "Capilano Indian Reserve 5",
 *          "Place.Municipality": "West Vancouver",
 *          "Place.SubRegion": "Metro Vancouver",
 *          "Place.Region": "British Columbia",
 *          "Place.Country": "CAN",
 *          "Place.PostalCode": "V7T",
 *          "Place.Interpolated": false,
 *          "Place.TimeZone.Name": "America/Vancouver",
 *          "Place.TimeZone.Offset": -25200
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-123.142, 49.325]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @param place Response of the GetPlace or SearchPlace* API.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON FeatureCollection
 */function placeToFeatureCollection(place,options){if("Results"in place){var features=place.Results.map(function(result){return result&&convertPlaceToFeature(result,options)});return toFeatureCollection(features)}else if("Place"in place){var _features=[convertPlaceToFeature(place,options)];return toFeatureCollection(_features)}else{return emptyFeatureCollection()}}/**
 * Convert an Amazon Location Place object to a GeoJSON Feature.
 *
 * @param place The Place object from Amazon Location SDK.
 * @param options Options for flattening the properties.
 * @returns A GeoJSON Feature of the Place object, or null if there isn't the Geometry.Point property present.
 */function convertPlaceToFeature(place,options){var _a,_b,_c;var coordinates=(_b=(_a=place.Place)===null||_a===void 0?void 0:_a.Geometry)===null||_b===void 0?void 0:_b.Point;if(coordinates){var placeClone=Object.assign({},place);(_c=placeClone.Place)===null||_c===void 0?true:delete _c.Geometry;if("PlaceId"in placeClone){delete placeClone.PlaceId}var properties=(options===null||options===void 0?void 0:options.flattenProperties)?flattenProperties(Object.assign({},placeClone)):Object.assign({},placeClone);var _feature={type:"Feature",id:"PlaceId"in place?place.PlaceId:undefined,properties:properties,geometry:{type:"Point",coordinates:coordinates}};return _feature}return null}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __rest=undefined&&undefined.__rest||function(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols==="function")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]]}return t};/**
 * It converts tracker responses to a FeatureCollection with Point Features. It converts
 *
 * 1. GetDevicePositionResponse to a FeatureCollection with a single feature.
 * 2. BatchGetDevicePositionResponse, GetDevicePositionHistoryResponse, ListDevicePositionsResponse to a FeatureCollection
 *    with features corresponding to the entries in the response.
 *
 * Fields other than `Position` of the device position will be mapped into the properties of the corresponding Feature.
 *
 * @example Converting a GetDevicePosition result
 *
 * Result of GetDevicePosition:
 *
 * ```json
 * {
 *   "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "SampleTime": "2023-04-18T21:35:44Z",
 *   "Position": [-125.14, 49.29],
 *   "Accuracy": {
 *     "Horizontal": 1
 *   },
 *   "PositionProperties": {
 *     "RouteNumber": "66",
 *     "Speed": "45mph"
 *   }
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:33:44Z",
 *         "PositionProperties": {
 *           "RouteNumber": "66",
 *           "Speed": "45mph"
 *         },
 *         "Accuracy": {
 *           "Horizontal": 1
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a ListDevicePositions result
 *
 * Result of ListDevicePositions:
 *
 * ```json
 * {
 *   "Entries": [
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:35:44Z",
 *       "Position": [-125.14, 49.29],
 *       "PositionProperties": {
 *         "RouteNumber": "66",
 *         "Speed": "45mph"
 *       },
 *       "Accuracy": {
 *         "Horizontal": 1
 *       }
 *     },
 *     {
 *       "DeviceId": "D775D81A-BF1B-4311-9D54-2DCCA2B0BECA",
 *       "SampleTime": "2023-04-18T21:40:44Z",
 *       "Position": [-120.57, 50.36]
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:35:44Z",
 *         "PositionProperties": {
 *           "RouteNumber": "66",
 *           "Speed": "45mph"
 *         },
 *         "Accuracy": {
 *           "Horizontal": 1
 *         }
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "D775D81A-BF1B-4311-9D54-2DCCA2B0BECA",
 *         "SampleTime": "2023-04-18T21:40:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-120.57, 50.36]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a GetDevicePositionHistory result
 *
 * Result of GetDevicePositionHistory:
 *
 * ```json
 * {
 *   "DevicePositions": [
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:35:44Z",
 *       "ReceivedTime": "2023-04-18T21:35:44Z",
 *       "Position": [-125.25, 49.32]
 *     },
 *     {
 *       "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "SampleTime": "2023-04-18T21:50:44Z",
 *       "ReceivedTime": "2023-04-18T21:50:44Z",
 *       "Position": [-125.14, 49.29]
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:35:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.25, 49.32]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DeviceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *         "SampleTime": "2023-04-18T21:50:44Z"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-125.14, 49.29]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function devicePositionsToFeatureCollection(devicePositions){if("Position"in devicePositions){var features=[convertDevicePositionToFeature(devicePositions)];return toFeatureCollection(features)}else if("DevicePositions"in devicePositions){var _features2=devicePositions.DevicePositions.map(function(result){return result&&convertDevicePositionToFeature(result)});return toFeatureCollection(_features2)}else if("Entries"in devicePositions){var _features3=devicePositions.Entries.map(function(result){return result&&convertDevicePositionToFeature(result)});return toFeatureCollection(_features3)}else{return emptyFeatureCollection()}}function convertDevicePositionToFeature(devicePosition){var Position=devicePosition.Position,devicePositionProperties=__rest(devicePosition,["Position"]);if(Position){return{type:"Feature",properties:Object.assign({},devicePositionProperties),geometry:{type:"Point",coordinates:Position}}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a route to a GeoJSON FeatureCollection with a single MultiStringLine Feature, each LineString entry of
 * such MultiLineString represents a leg of the route.
 *
 * Fields other than `Legs` of the route will be mapped to a field of the Feature's properties.
 *
 * Any leg without the `Geometry` field will be skipped.
 *
 * Note: <b>IncludeLegGeometry</b> should be set to true when calling CalculateRoute or Geometry will not be present in
 * the result and such result will be converted to an empty MultiLineString.
 *
 * @example Converting a CalculateRoute result with 2 legs
 *
 * Result of CalculateRoute:
 *
 * ```json
 * {
 *   "Legs": [
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.88,
 *       "EndPosition": [123.0, 12.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 11.0],
 *           [123.5, 11.5],
 *           [123.0, 12.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 11.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 9.4,
 *       "EndPosition": [123.0, 14.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 12.0],
 *           [123.5, 13.5],
 *           [123.0, 14.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 12.0],
 *       "Steps": []
 *     }
 *   ],
 *   "Summary": {
 *     "DataSource": "Esri",
 *     "Distance": 1,
 *     "DistanceUnit": "Kilometers",
 *     "DurationSeconds": 30,
 *     "RouteBBox": [-123.149, 49.289, -123.141, 49.287]
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Summary": {
 *           "DataSource": "Esri",
 *           "Distance": 1,
 *           "DistanceUnit": "Kilometers",
 *           "DurationSeconds": 30
 *         }
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 12.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DataSource": "Esri",
 *         "Distance": 1,
 *         "DistanceUnit": "Kilometers",
 *         "DurationSeconds": 30
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 12.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a CalculateRoute result with the second leg missing the `Geometry` field
 *
 * Result of CalculateRoute:
 *
 * ```json
 * {
 *   "Legs": [
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.88,
 *       "EndPosition": [123.0, 12.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 11.0],
 *           [123.5, 11.5],
 *           [123.0, 12.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 11.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 10.7,
 *       "EndPosition": [123.0, 13.0],
 *       "StartPosition": [123.0, 12.0],
 *       "Steps": []
 *     },
 *     {
 *       "Distance": 0.05,
 *       "DurationSeconds": 9.4,
 *       "EndPosition": [123.0, 14.0],
 *       "Geometry": {
 *         "LineString": [
 *           [123.0, 13.0],
 *           [123.5, 13.5],
 *           [123.0, 14.0]
 *         ]
 *       },
 *       "StartPosition": [123.0, 13.0],
 *       "Steps": []
 *     }
 *   ],
 *   "Summary": {
 *     "DataSource": "Esri",
 *     "Distance": 1,
 *     "DistanceUnit": "Kilometers",
 *     "DurationSeconds": 30,
 *     "RouteBBox": [-123.149, 49.289, -123.141, 49.287]
 *   }
 * }
 * ```
 *
 * Output flattenProperties is false:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "Summary": {
 *           "DataSource": "Esri",
 *           "Distance": 1,
 *           "DistanceUnit": "Kilometers",
 *           "DurationSeconds": 30
 *         }
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 13.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * - Output flattenProperties is true:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "DataSource": "Esri",
 *         "Distance": 1,
 *         "DistanceUnit": "Kilometers",
 *         "DurationSeconds": 30
 *       },
 *       "geometry": {
 *         "type": "MultiLineString",
 *         "coordinates": [
 *           [
 *             [123.0, 11.0],
 *             [123.5, 11.5],
 *             [123.0, 12.0]
 *           ],
 *           [
 *             [123.0, 13.0],
 *             [123.5, 13.5],
 *             [123.0, 14.0]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function routeToFeatureCollection(route,options){var Legs=route.Legs;return Legs?toFeatureCollection([convertRouteToFeature(route,options)]):emptyFeatureCollection()}/**
 * Convert an Amazon Location Service route object to a GeoJSON Feature.
 *
 * @param route The route object from Amazon Location Service.
 * @returns A GeoJSON Feature of the route object.
 */function convertRouteToFeature(route,options){var _a;var processedLegs=route.Legs.map(function(leg){var _a;return(_a=leg.Geometry)===null||_a===void 0?void 0:_a.LineString}).filter(function(leg){return leg});var properties={};if(options===null||options===void 0?void 0:options.flattenProperties){properties=flattenProperties(route.Summary,"")}else if(route.Summary){properties.Summary=Object.assign(Object.assign({},route.Summary),{RouteBBox:undefined})}delete properties.RouteBBox;return{type:"Feature",properties:properties,bbox:(_a=route.Summary)===null||_a===void 0?void 0:_a.RouteBBox,geometry:{type:"MultiLineString",coordinates:processedLegs}}}// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
/**
 * It converts a list of geofences to FeatureCollection with Polygon Features. It can convert geofences both in the
 * response and the request, so it can also help previewing geofences on the map before uploading with PutGeofence or
 * BatchPutGeofence.
 *
 * It will convert:
 *
 * 1. A Polygon Geofence to a Feature with such Polygon
 * 2. A Circle Geofence to a Feature with approximated Polygon with `Center` and `Radius` properties.
 *
 * `GeofenceId` field in the input will be mapped to the id of the corresponding Feature. Fields other then `GeofenceId`
 * and `Geometry` will be mapped into the properties of the corresponding Feature.
 *
 * Any geofence without any of `Polygon` or `Circle` geometry will be skipped.
 *
 * @example Converting a polygon geofence
 *
 * Result of a polygon geofence from GetGeofence:
 *
 * ```json
 * {
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Polygon": [
 *       [
 *         [1, 2],
 *         [1, 3],
 *         [2, 3],
 *         [1, 2]
 *       ]
 *     ]
 *   },
 *   "Status": "ACTIVE",
 *   "CreateTime": "2023-04-18T21:35:44Z",
 *   "UpdateTime": "2023-04-18T23:20:41Z"
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a circle geofence
 *
 * Result of a circle geofence from GetGeofence:
 *
 * ```json
 * {
 *   "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *   "Geometry": {
 *     "Circle": {
 *       "Center": [1, 2],
 *       "Radius": 10.0
 *     }
 *   },
 *   "Status": "ACTIVE",
 *   "CreateTime": "2023-04-18T21:35:44Z",
 *   "UpdateTime": "2023-04-18T23:20:41Z"
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 *
 * @example Converting a ListGeofences result with the second result missing the `Polygon` and `Circle` field
 *
 * Result of ListGeofences:
 *
 * ```json
 * {
 *   "Entries": [
 *     {
 *       "GeofenceId": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "Geometry": {
 *         "Polygon": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       },
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     },
 *     {
 *       "GeofenceId": "1B4C6411-4A12-4219-4A12-AB5AEE6CD5XE",
 *       "Geometry": {},
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     },
 *     {
 *       "GeofenceId": "7D6C3456-4A12-4219-A99D-CD4AEE6DK4TX",
 *       "Geometry": {
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "Status": "ACTIVE",
 *       "CreateTime": "2023-04-18T21:35:44Z",
 *       "UpdateTime": "2023-04-18T23:20:41Z"
 *     }
 *   ]
 * }
 * ```
 *
 * Output:
 *
 * ```json
 * {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "id": "0C1E4574-4A12-4219-A99D-AE4AEE6DE1AC",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z"
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [1, 2],
 *             [1, 3],
 *             [2, 3],
 *             [1, 2]
 *           ]
 *         ]
 *       }
 *     },
 *     {
 *       "type": "Feature",
 *       "id": "7D6C3456-4A12-4219-A99D-CD4AEE6DK4TX",
 *       "properties": {
 *         "Status": "ACTIVE",
 *         "CreateTime": "2023-04-18T21:35:44Z",
 *         "UpdateTime": "2023-04-18T23:20:41Z",
 *         "Circle": {
 *           "Center": [1, 2],
 *           "Radius": 10.0
 *         }
 *       },
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           // ... approximated Polygon
 *         ]
 *       }
 *     }
 *   ]
 * }
 * ```
 */function geofencesToFeatureCollection(geofences){if("Entries"in geofences){return toFeatureCollection(geofences.Entries.map(function(geofence){return geofenceToFeature(geofence)}))}else{return toFeatureCollection([geofenceToFeature(geofences)])}}function geofenceToFeature(geofence){if(geofence){var result=convertGeometryToFeature(geofence===null||geofence===void 0?void 0:geofence.Geometry,geofence);if(result){delete result.properties.Geometry;if("GeofenceId"in geofence){result.id=geofence.GeofenceId;delete result.properties.GeofenceId}return result}}}});
